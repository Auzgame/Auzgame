// Generated by Haxe 3.4.7
(function ($global) { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Pathfinder = function(thread) {
	this.emptySeen = null;
	this.seen = null;
	this.finalPathsPos = 1;
	this.handledAirConnections = null;
	this.thread = thread;
	this.pathQueue = new de_polygonal_ds_PriorityQueue(10,true);
};
Pathfinder.__name__ = true;
Pathfinder.prototype = {
	handleMessage: function(data) {
		var _g = data[0];
		switch(_g) {
		case 0:
			this.handleGetFullWorldInfo(data);
			break;
		case 1:
			this.findPaths(data);
			break;
		case 2:
			break;
		}
	}
	,findPaths: function(data) {
		var dataPos = 2;
		var numberOfPaths = data[1];
		var _g1 = 0;
		var _g = numberOfPaths;
		while(_g1 < _g) {
			var i = _g1++;
			this.findPath(data[dataPos++],data[dataPos++],data[dataPos++],data[dataPos++],numberOfPaths - i);
		}
		this.sendPathsMessage();
	}
	,findPath: function(data0,data1,goal,privateTeleporter,pathsLeft) {
		var _gthis = this;
		this.pathQueue.clear();
		if(this.seen == null || this.seen.length != this.amountOfBuildings) {
			this.seen = new Int8Array(this.amountOfBuildings);
			this.emptySeen = new Int8Array(this.amountOfBuildings);
		} else {
			this.seen.set(this.emptySeen);
		}
		if(this.handledAirConnections == null || this.handledAirConnections.length != this.airGroupLength) {
			var _g = [];
			var _g2 = 0;
			var _g1 = this.airGroupLength;
			while(_g2 < _g1) {
				var i = _g2++;
				_g.push(0);
			}
			this.handledAirConnections = _g;
		} else {
			var _g11 = 0;
			var _g3 = this.airGroupLength;
			while(_g11 < _g3) {
				var i1 = _g11++;
				this.handledAirConnections[i1] = 0;
			}
		}
		var startsOutsideOfBuilding = data0 != -1;
		if(!startsOutsideOfBuilding) {
			var building = this.buildingsByID.h[data1];
			building.inEdge = null;
			building.previousBuilding = null;
			var _this = building;
			_this.priority = 0;
			this.pathQueue.enqueue(_this);
			this.seen[building.continuousID] = 1;
		} else {
			var _g4 = 0;
			var _g12 = this.bottomBuildingsOfWorlds[data0];
			while(_g4 < _g12.length) {
				var connection = _g12[_g4];
				++_g4;
				var building1 = connection.to;
				building1.inEdge = null;
				building1.previousBuilding = null;
				var _this1 = building1;
				var val = building1.x - data1;
				_this1.priority = val < 0 ? -val : val;
				this.pathQueue.enqueue(_this1);
				this.seen[building1.continuousID] = 1;
			}
		}
		var handledTeleporterConnections = false;
		while(this.pathQueue.mSize != 0) {
			var currentBuilding = this.pathQueue.dequeue();
			if(currentBuilding.id == goal) {
				var pathLength = 0;
				var backtraceBuilding = currentBuilding;
				while(backtraceBuilding.previousBuilding != null) {
					backtraceBuilding = backtraceBuilding.previousBuilding;
					++pathLength;
				}
				if(startsOutsideOfBuilding) {
					++pathLength;
				}
				this.generateNewPathsArrayIfNeeded(pathLength * 2,pathsLeft);
				this.finalPaths[0] += 1;
				this.finalPaths[this.finalPathsPos++] = pathLength * 2;
				this.finalPathsPos += pathLength * 2;
				var backtraceBuilding1 = currentBuilding;
				while(backtraceBuilding1.previousBuilding != null) {
					this.finalPathsPos -= 2;
					this.finalPaths[this.finalPathsPos] = backtraceBuilding1.inEdge.type;
					this.finalPaths[this.finalPathsPos + 1] = backtraceBuilding1.id;
					backtraceBuilding1 = backtraceBuilding1.previousBuilding;
				}
				if(startsOutsideOfBuilding) {
					this.finalPathsPos -= 2;
					this.finalPaths[this.finalPathsPos] = 5;
					this.finalPaths[this.finalPathsPos + 1] = backtraceBuilding1.id;
				}
				this.finalPathsPos += pathLength * 2;
				return;
			}
			this.seen[currentBuilding.continuousID] = 2;
			var _g5 = 0;
			var _g13 = currentBuilding.connections;
			while(_g5 < _g13.length) {
				var connectionList = _g13[_g5];
				++_g5;
				var _g21 = 0;
				while(_g21 < connectionList.length) {
					var connection1 = connectionList[_g21];
					++_g21;
					var newPriority = currentBuilding.priority + connection1.extraPriorityIfKnown;
					var buildingTo = connection1.to;
					var _g6 = _gthis.seen[buildingTo.continuousID];
					switch(_g6) {
					case 0:
						buildingTo.inEdge = connection1;
						buildingTo.previousBuilding = currentBuilding;
						var _this2 = buildingTo;
						_this2.priority = newPriority;
						_gthis.pathQueue.enqueue(_this2);
						_gthis.seen[buildingTo.continuousID] = 1;
						break;
					case 1:
						if(newPriority < buildingTo.priority) {
							buildingTo.inEdge = connection1;
							buildingTo.previousBuilding = currentBuilding;
							_gthis.pathQueue.reprioritize(buildingTo,newPriority);
						}
						break;
					}
				}
			}
			if(currentBuilding.type == 2) {
				var airGroup = this.airGroups.h[currentBuilding.__id__];
				if(this.handledAirConnections[airGroup] < 5) {
					var x = this.worldX[currentBuilding.world] + currentBuilding.x;
					var y = this.worldY[currentBuilding.world] - currentBuilding.get_y();
					var _g7 = 0;
					var _g14 = this.airGroupConnections[airGroup];
					while(_g7 < _g14.length) {
						var landingSite = _g14[_g7];
						++_g7;
						var buildingTo1 = landingSite.to;
						if(buildingTo1 == currentBuilding) {
							continue;
						}
						var estimatedPriorityAdd;
						if(buildingTo1.world == currentBuilding.world) {
							var maxY = 0;
							var val1 = currentBuilding.xIndex;
							var val2 = buildingTo1.xIndex;
							var _g31 = val2 < val1 ? val2 : val1;
							var val11 = currentBuilding.xIndex;
							var val21 = buildingTo1.xIndex;
							var _g22 = 1 + (val21 > val11 ? val21 : val11);
							while(_g31 < _g22) {
								var xx = _g31++;
								var val22 = this.worlds[currentBuilding.world][xx].length;
								if(val22 > maxY) {
									maxY = val22;
								} else {
									maxY = maxY;
								}
							}
							estimatedPriorityAdd = 10 + (Math.abs(buildingTo1.x - currentBuilding.x) + 20 * (maxY - buildingTo1.yIndex + maxY - currentBuilding.yIndex)) / 3;
						} else {
							estimatedPriorityAdd = (Math.abs(this.worldX[buildingTo1.world] + buildingTo1.x - x) + Math.abs(this.worldY[buildingTo1.world] - buildingTo1.get_y() - y)) / 1.5;
						}
						var newPriority1 = currentBuilding.priority + estimatedPriorityAdd;
						var buildingTo2 = landingSite.to;
						var _g8 = _gthis.seen[buildingTo2.continuousID];
						switch(_g8) {
						case 0:
							buildingTo2.inEdge = landingSite;
							buildingTo2.previousBuilding = currentBuilding;
							var _this3 = buildingTo2;
							_this3.priority = newPriority1;
							_gthis.pathQueue.enqueue(_this3);
							_gthis.seen[buildingTo2.continuousID] = 1;
							break;
						case 1:
							if(newPriority1 < buildingTo2.priority) {
								buildingTo2.inEdge = landingSite;
								buildingTo2.previousBuilding = currentBuilding;
								_gthis.pathQueue.reprioritize(buildingTo2,newPriority1);
							}
							break;
						}
					}
				}
				this.handledAirConnections[airGroup]++;
			} else if(!handledTeleporterConnections) {
				var isPersonalTeleporter = currentBuilding.id == privateTeleporter;
				if(currentBuilding.isTeleporter || isPersonalTeleporter) {
					var _g9 = 0;
					var _g15 = this.teleporterConnections;
					while(_g9 < _g15.length) {
						var connection2 = _g15[_g9];
						++_g9;
						var newPriority2 = currentBuilding.priority + connection2.extraPriorityIfKnown;
						var buildingTo3 = connection2.to;
						var _g10 = _gthis.seen[buildingTo3.continuousID];
						switch(_g10) {
						case 0:
							buildingTo3.inEdge = connection2;
							buildingTo3.previousBuilding = currentBuilding;
							var _this4 = buildingTo3;
							_this4.priority = newPriority2;
							_gthis.pathQueue.enqueue(_this4);
							_gthis.seen[buildingTo3.continuousID] = 1;
							break;
						case 1:
							if(newPriority2 < buildingTo3.priority) {
								buildingTo3.inEdge = connection2;
								buildingTo3.previousBuilding = currentBuilding;
								_gthis.pathQueue.reprioritize(buildingTo3,newPriority2);
							}
							break;
						}
					}
					if(!isPersonalTeleporter && privateTeleporter >= 0) {
						var tpBuilding = this.buildingsByID.h[privateTeleporter];
						var connection3 = new PathfindingEdge(7,tpBuilding);
						var newPriority3 = currentBuilding.priority + 10;
						var _g16 = _gthis.seen[tpBuilding.continuousID];
						switch(_g16) {
						case 0:
							tpBuilding.inEdge = connection3;
							tpBuilding.previousBuilding = currentBuilding;
							var _this5 = tpBuilding;
							_this5.priority = newPriority3;
							_gthis.pathQueue.enqueue(_this5);
							_gthis.seen[tpBuilding.continuousID] = 1;
							break;
						case 1:
							if(newPriority3 < tpBuilding.priority) {
								tpBuilding.inEdge = connection3;
								tpBuilding.previousBuilding = currentBuilding;
								_gthis.pathQueue.reprioritize(tpBuilding,newPriority3);
							}
							break;
						}
					}
					handledTeleporterConnections = true;
				}
			}
			if(currentBuilding.isBottomBuilding && (currentBuilding.inEdge == null || currentBuilding.inEdge.type != 5)) {
				var _g17 = 0;
				var _g18 = this.bottomBuildingsOfWorlds[currentBuilding.world];
				while(_g17 < _g18.length) {
					var connection4 = _g18[_g17];
					++_g17;
					var building2 = connection4.to;
					var val3 = building2.x - currentBuilding.x;
					var newPriority4 = currentBuilding.priority + (val3 < 0 ? -val3 : val3);
					var _g19 = _gthis.seen[building2.continuousID];
					switch(_g19) {
					case 0:
						building2.inEdge = connection4;
						building2.previousBuilding = currentBuilding;
						var _this6 = building2;
						_this6.priority = newPriority4;
						_gthis.pathQueue.enqueue(_this6);
						_gthis.seen[building2.continuousID] = 1;
						break;
					case 1:
						if(newPriority4 < building2.priority) {
							building2.inEdge = connection4;
							building2.previousBuilding = currentBuilding;
							_gthis.pathQueue.reprioritize(building2,newPriority4);
						}
						break;
					}
				}
			}
		}
		this.generateNewPathsArrayIfNeeded(1,pathsLeft);
		this.finalPaths[0] += 1;
		this.finalPaths[this.finalPathsPos++] = 1;
		this.finalPaths[this.finalPathsPos++] = -1;
	}
	,generateNewPathsArrayIfNeeded: function(pathLength,pathsLeft) {
		if(this.finalPaths != null && this.finalPathsPos + pathLength + 1 > this.finalPaths.length) {
			this.sendPathsMessage();
		}
		if(this.finalPaths == null) {
			var val2 = (pathLength + 2) * pathsLeft + 1;
			this.finalPaths = new Int32Array(val2 > 21 ? val2 : 21);
		}
	}
	,sendPathsMessage: function() {
		if(this.finalPathsPos > 1) {
			this.thread.postInt32Array(this.finalPaths);
			this.finalPaths = null;
			this.finalPathsPos = 1;
		}
	}
	,handleGetFullWorldInfo: function(data) {
		var continuousBuildingID = 0;
		var i = 2;
		this.teleporterConnections = [];
		this.buildingsByID = new haxe_ds_IntMap();
		this.worlds = [];
		this.worldX = [];
		this.worldY = [];
		this.bottomBuildingsOfWorlds = [];
		var numberOfWorlds = data[1];
		var _g1 = 0;
		var _g = numberOfWorlds;
		while(_g1 < _g) {
			var w = _g1++;
			var numberOfBuildingArrays = data[i++];
			this.worldX.push(data[i++]);
			this.worldY.push(data[i++]);
			var buildingArray = [];
			this.worlds.push(buildingArray);
			var worldBottomBuildings = [];
			this.bottomBuildingsOfWorlds.push(worldBottomBuildings);
			var _g3 = 0;
			var _g2 = numberOfBuildingArrays;
			while(_g3 < _g2) {
				var b = _g3++;
				var buildings = [];
				buildingArray.push(buildings);
				var buildingNumber = data[i++];
				var previousElevatorBuilding = null;
				var distanceToPreviousElevatorBuilding = 0;
				var _g5 = 0;
				var _g4 = buildingNumber;
				while(_g5 < _g4) {
					var bl = _g5++;
					var buildingID = data[i++];
					if(buildingID != -1) {
						++distanceToPreviousElevatorBuilding;
						var buildingType = data[i++];
						var isRooftopBuilding = buildingType % 2 == 1;
						buildingType >>= 1;
						var thisBuilding = new PathfindingBuilding(buildingID,continuousBuildingID++,buildingType,b * 20,w,bl,isRooftopBuilding);
						if(bl == 0) {
							thisBuilding.isBottomBuilding = true;
							worldBottomBuildings.push(new PathfindingEdge(5,thisBuilding));
						}
						if(buildingType == 1) {
							thisBuilding.isTeleporter = true;
							this.teleporterConnections.push(new PathfindingEdge(7,thisBuilding,10));
						}
						if(buildingType == 3) {
							thisBuilding.isNonBuildingPermanent = true;
						}
						if(buildingType == 4) {
							if(previousElevatorBuilding != null) {
								previousElevatorBuilding.connections.push([new PathfindingEdge(13,thisBuilding,distanceToPreviousElevatorBuilding)]);
								thisBuilding.connections.push([new PathfindingEdge(13,previousElevatorBuilding,distanceToPreviousElevatorBuilding)]);
							}
							previousElevatorBuilding = thisBuilding;
							distanceToPreviousElevatorBuilding = 0;
						}
						buildings.push(thisBuilding);
						this.buildingsByID.h[buildingID] = thisBuilding;
					} else {
						buildings.push(null);
						previousElevatorBuilding = null;
						++i;
					}
				}
			}
			var _g31 = 0;
			var _g21 = numberOfBuildingArrays;
			while(_g31 < _g21) {
				var x = _g31++;
				var _g51 = 0;
				var _g41 = buildingArray[x].length;
				while(_g51 < _g41) {
					var y = _g51++;
					var walkThroughEdges = [];
					var thisBuilding1 = buildingArray[x][y];
					if(thisBuilding1 == null) {
						continue;
					}
					if(thisBuilding1.isNonBuildingPermanent) {
						continue;
					}
					var thisIsRooftopBuilding = buildingArray[x][y].isRooftopBuilding;
					if(x > 0 && y > 0 && buildingArray[x - 1].length > y && !thisIsRooftopBuilding && buildingArray[x - 1][y] != null && !buildingArray[x - 1][y].isRooftopBuilding) {
						walkThroughEdges.push(new PathfindingEdge(2,buildingArray[x - 1][y]));
					}
					if(x < numberOfBuildingArrays - 1 && y > 0 && buildingArray[x + 1].length > y && !thisIsRooftopBuilding && buildingArray[x + 1][y] != null && !buildingArray[x + 1][y].isRooftopBuilding) {
						walkThroughEdges.push(new PathfindingEdge(3,buildingArray[x + 1][y]));
					}
					if(y < buildingArray[x].length - 1 && buildingArray[x][y + 1] != null) {
						walkThroughEdges.push(new PathfindingEdge(0,buildingArray[x][y + 1]));
					}
					if(y > 0 && buildingArray[x][y - 1] != null && !buildingArray[x][y - 1].isNonBuildingPermanent) {
						walkThroughEdges.push(new PathfindingEdge(1,buildingArray[x][y - 1]));
					}
					thisBuilding1.connections.push(walkThroughEdges);
				}
			}
		}
		var extraConnectionNum = data[i++];
		var _g11 = 0;
		var _g6 = extraConnectionNum;
		while(_g11 < _g6) {
			var j = _g11++;
			var connectionType = data[i++];
			var thisBuilding2 = this.buildingsByID.h[data[i++]];
			var otherBuilding = this.buildingsByID.h[data[i++]];
			this.worlds[thisBuilding2.world][thisBuilding2.x / 20 | 0][thisBuilding2.yIndex].connections.push([new PathfindingEdge(connectionType,otherBuilding)]);
		}
		var airConnectionGroupsNumber = data[i++];
		this.airGroupLength = 0;
		this.airGroupConnections = [];
		this.airGroups = new haxe_ds_ObjectMap();
		var _g12 = 0;
		var _g7 = airConnectionGroupsNumber;
		while(_g12 < _g7) {
			var j1 = _g12++;
			var groupSize = data[i++];
			var thisAirGroupConnections = [];
			var _g32 = 0;
			var _g22 = groupSize;
			while(_g32 < _g22) {
				var k = _g32++;
				var thisBuilding3 = this.buildingsByID.h[data[i++]];
				this.airGroups.set(thisBuilding3,j1);
				thisAirGroupConnections.push(new PathfindingEdge(11,thisBuilding3));
			}
			this.airGroupConnections.push(thisAirGroupConnections);
			this.airGroupLength += 1;
		}
		this.amountOfBuildings = continuousBuildingID;
	}
	,__class__: Pathfinder
};
var PathfinderThread = function() {
	this.useModernPostMessage = false;
	PathfinderThread.__internal__self = this;
	this.pathfinder = new Pathfinder(this);
	this.useModernPostMessage = false;
};
PathfinderThread.__name__ = true;
PathfinderThread.main = function() {
	new PathfinderThread();
};
PathfinderThread.prototype = {
	onMessage: function(e) {
		var data = new Int32Array(e.data);
		if(data[0] == 2) {
			this.useModernPostMessage = true;
			return;
		}
		this.pathfinder.handleMessage(data);
	}
	,postInt32Array: function(arrayToPost) {
		if(this.useModernPostMessage) {
			postMessage(arrayToPost.buffer, [arrayToPost.buffer]);
		} else {
			postMessage(arrayToPost.buffer);
		}
	}
	,__internal__onMessage: function(e) {
		PathfinderThread.__internal__self.onMessage(e);
	}
	,__class__: PathfinderThread
};
var de_polygonal_ds_Prioritizable = function() { };
de_polygonal_ds_Prioritizable.__name__ = true;
de_polygonal_ds_Prioritizable.prototype = {
	__class__: de_polygonal_ds_Prioritizable
};
var PathfindingBuilding = function(id,continuousID,type,x,world,yIndex,isRooftopBuilding) {
	this.connections = [];
	this.id = id;
	this.continuousID = continuousID;
	this.type = type;
	this.x = x;
	this.xIndex = x / 20 | 0;
	this.world = world;
	this.yIndex = yIndex;
	this.isRooftopBuilding = isRooftopBuilding;
};
PathfindingBuilding.__name__ = true;
PathfindingBuilding.__interfaces__ = [de_polygonal_ds_Prioritizable];
PathfindingBuilding.prototype = {
	get_y: function() {
		return this.yIndex * 20;
	}
	,__class__: PathfindingBuilding
};
var PathfindingEdge = function(type,to,extraPriority) {
	if(extraPriority == null) {
		extraPriority = 20;
	}
	this.type = type;
	this.to = to;
	this.extraPriorityIfKnown = extraPriority;
};
PathfindingEdge.__name__ = true;
PathfindingEdge.prototype = {
	__class__: PathfindingEdge
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var de_polygonal_ds_Hashable = function() { };
de_polygonal_ds_Hashable.__name__ = true;
var de_polygonal_ds_Collection = function() { };
de_polygonal_ds_Collection.__name__ = true;
de_polygonal_ds_Collection.__interfaces__ = [de_polygonal_ds_Hashable];
de_polygonal_ds_Collection.prototype = {
	__class__: de_polygonal_ds_Collection
};
var de_polygonal_ds_Queue = function() { };
de_polygonal_ds_Queue.__name__ = true;
de_polygonal_ds_Queue.__interfaces__ = [de_polygonal_ds_Collection];
var de_polygonal_ds_PriorityQueue = function(initalCapacity,inverse,source) {
	if(inverse == null) {
		inverse = false;
	}
	if(initalCapacity == null) {
		initalCapacity = 1;
	}
	this.mSize = 0;
	this.growthRate = -2;
	this.mInitialCapacity = 1 > initalCapacity ? 1 : initalCapacity;
	this.capacity = initalCapacity;
	this.mInverse = inverse;
	if(source != null) {
		this.mSize = source.length;
		var x = this.mSize;
		var y = this.capacity;
		this.capacity = x > y ? x : y;
	}
	var len = this.capacity + 1;
	this.mData = new Array(len);
	this.mData[0] = null;
	if(source != null) {
		var d = this.mData;
		var _g1 = 1;
		var _g = this.mSize + 1;
		while(_g1 < _g) {
			var i = _g1++;
			d[i] = source[i - 1];
		}
		this.repair();
	}
};
de_polygonal_ds_PriorityQueue.__name__ = true;
de_polygonal_ds_PriorityQueue.__interfaces__ = [de_polygonal_ds_Queue];
de_polygonal_ds_PriorityQueue.prototype = {
	enqueue: function(val) {
		if(this.mSize == this.capacity) {
			this.grow();
		}
		this.mData[++this.mSize] = val;
		val.position = this.mSize;
		var index = this.mSize;
		var d = this.mData;
		var parent = index >> 1;
		var t = d[index];
		var p = t.priority;
		if(this.mInverse) {
			while(parent > 0) {
				var parentVal = d[parent];
				if(p - parentVal.priority < 0) {
					d[index] = parentVal;
					parentVal.position = index;
					index = parent;
					parent >>= 1;
				} else {
					break;
				}
			}
		} else {
			while(parent > 0) {
				var parentVal1 = d[parent];
				if(p - parentVal1.priority > 0) {
					d[index] = parentVal1;
					parentVal1.position = index;
					index = parent;
					parent >>= 1;
				} else {
					break;
				}
			}
		}
		d[index] = t;
		t.position = index;
	}
	,dequeue: function() {
		var d = this.mData;
		var x = d[1];
		var d1 = this.mData;
		x.position = -1;
		d1[1] = d1[this.mSize];
		var index = 1;
		var d2 = this.mData;
		var child = index << 1;
		var childVal;
		var t = d2[index];
		var p = t.priority;
		if(this.mInverse) {
			while(child < this.mSize) {
				if(child < this.mSize - 1) {
					if(d2[child].priority - d2[child + 1].priority > 0) {
						++child;
					}
				}
				childVal = d2[child];
				if(p - childVal.priority > 0) {
					d2[index] = childVal;
					childVal.position = index;
					t.position = child;
					index = child;
					child <<= 1;
				} else {
					break;
				}
			}
		} else {
			while(child < this.mSize) {
				if(child < this.mSize - 1) {
					if(d2[child].priority - d2[child + 1].priority < 0) {
						++child;
					}
				}
				childVal = d2[child];
				if(p - childVal.priority < 0) {
					d2[index] = childVal;
					childVal.position = index;
					t.position = child;
					index = child;
					child <<= 1;
				} else {
					break;
				}
			}
		}
		d2[index] = t;
		t.position = index;
		this.mSize--;
		return x;
	}
	,reprioritize: function(val,priority) {
		var oldPriority = val.priority;
		if(oldPriority == priority) {
			return this;
		}
		val.priority = priority;
		var pos = val.position;
		if(this.mInverse) {
			if(priority < oldPriority) {
				var index = pos;
				var d = this.mData;
				var parent = index >> 1;
				var t = d[index];
				var p = t.priority;
				if(this.mInverse) {
					while(parent > 0) {
						var parentVal = d[parent];
						if(p - parentVal.priority < 0) {
							d[index] = parentVal;
							parentVal.position = index;
							index = parent;
							parent >>= 1;
						} else {
							break;
						}
					}
				} else {
					while(parent > 0) {
						var parentVal1 = d[parent];
						if(p - parentVal1.priority > 0) {
							d[index] = parentVal1;
							parentVal1.position = index;
							index = parent;
							parent >>= 1;
						} else {
							break;
						}
					}
				}
				d[index] = t;
				t.position = index;
			} else {
				var index1 = pos;
				var d1 = this.mData;
				var child = index1 << 1;
				var childVal;
				var t1 = d1[index1];
				var p1 = t1.priority;
				if(this.mInverse) {
					while(child < this.mSize) {
						if(child < this.mSize - 1) {
							if(d1[child].priority - d1[child + 1].priority > 0) {
								++child;
							}
						}
						childVal = d1[child];
						if(p1 - childVal.priority > 0) {
							d1[index1] = childVal;
							childVal.position = index1;
							t1.position = child;
							index1 = child;
							child <<= 1;
						} else {
							break;
						}
					}
				} else {
					while(child < this.mSize) {
						if(child < this.mSize - 1) {
							if(d1[child].priority - d1[child + 1].priority < 0) {
								++child;
							}
						}
						childVal = d1[child];
						if(p1 - childVal.priority < 0) {
							d1[index1] = childVal;
							childVal.position = index1;
							t1.position = child;
							index1 = child;
							child <<= 1;
						} else {
							break;
						}
					}
				}
				d1[index1] = t1;
				t1.position = index1;
				var index2 = this.mSize;
				var d2 = this.mData;
				var parent1 = index2 >> 1;
				var t2 = d2[index2];
				var p2 = t2.priority;
				if(this.mInverse) {
					while(parent1 > 0) {
						var parentVal2 = d2[parent1];
						if(p2 - parentVal2.priority < 0) {
							d2[index2] = parentVal2;
							parentVal2.position = index2;
							index2 = parent1;
							parent1 >>= 1;
						} else {
							break;
						}
					}
				} else {
					while(parent1 > 0) {
						var parentVal3 = d2[parent1];
						if(p2 - parentVal3.priority > 0) {
							d2[index2] = parentVal3;
							parentVal3.position = index2;
							index2 = parent1;
							parent1 >>= 1;
						} else {
							break;
						}
					}
				}
				d2[index2] = t2;
				t2.position = index2;
			}
		} else if(priority > oldPriority) {
			var index3 = pos;
			var d3 = this.mData;
			var parent2 = index3 >> 1;
			var t3 = d3[index3];
			var p3 = t3.priority;
			if(this.mInverse) {
				while(parent2 > 0) {
					var parentVal4 = d3[parent2];
					if(p3 - parentVal4.priority < 0) {
						d3[index3] = parentVal4;
						parentVal4.position = index3;
						index3 = parent2;
						parent2 >>= 1;
					} else {
						break;
					}
				}
			} else {
				while(parent2 > 0) {
					var parentVal5 = d3[parent2];
					if(p3 - parentVal5.priority > 0) {
						d3[index3] = parentVal5;
						parentVal5.position = index3;
						index3 = parent2;
						parent2 >>= 1;
					} else {
						break;
					}
				}
			}
			d3[index3] = t3;
			t3.position = index3;
		} else {
			var index4 = pos;
			var d4 = this.mData;
			var child1 = index4 << 1;
			var childVal1;
			var t4 = d4[index4];
			var p4 = t4.priority;
			if(this.mInverse) {
				while(child1 < this.mSize) {
					if(child1 < this.mSize - 1) {
						if(d4[child1].priority - d4[child1 + 1].priority > 0) {
							++child1;
						}
					}
					childVal1 = d4[child1];
					if(p4 - childVal1.priority > 0) {
						d4[index4] = childVal1;
						childVal1.position = index4;
						t4.position = child1;
						index4 = child1;
						child1 <<= 1;
					} else {
						break;
					}
				}
			} else {
				while(child1 < this.mSize) {
					if(child1 < this.mSize - 1) {
						if(d4[child1].priority - d4[child1 + 1].priority < 0) {
							++child1;
						}
					}
					childVal1 = d4[child1];
					if(p4 - childVal1.priority < 0) {
						d4[index4] = childVal1;
						childVal1.position = index4;
						t4.position = child1;
						index4 = child1;
						child1 <<= 1;
					} else {
						break;
					}
				}
			}
			d4[index4] = t4;
			t4.position = index4;
			var index5 = this.mSize;
			var d5 = this.mData;
			var parent3 = index5 >> 1;
			var t5 = d5[index5];
			var p5 = t5.priority;
			if(this.mInverse) {
				while(parent3 > 0) {
					var parentVal6 = d5[parent3];
					if(p5 - parentVal6.priority < 0) {
						d5[index5] = parentVal6;
						parentVal6.position = index5;
						index5 = parent3;
						parent3 >>= 1;
					} else {
						break;
					}
				}
			} else {
				while(parent3 > 0) {
					var parentVal7 = d5[parent3];
					if(p5 - parentVal7.priority > 0) {
						d5[index5] = parentVal7;
						parentVal7.position = index5;
						index5 = parent3;
						parent3 >>= 1;
					} else {
						break;
					}
				}
			}
			d5[index5] = t5;
			t5.position = index5;
		}
		return this;
	}
	,clear: function(gc) {
		if(gc == null) {
			gc = false;
		}
		if(gc) {
			de_polygonal_ds_tools_NativeArrayTools.nullify(this.mData);
		}
		this.mSize = 0;
	}
	,repair: function() {
		var i = this.mSize >> 1;
		while(i >= 1) {
			this.heapify(i,this.mSize);
			--i;
		}
	}
	,heapify: function(p,s) {
		var d = this.mData;
		var l = p << 1;
		var r = l + 1;
		var max = p;
		if(this.mInverse) {
			if(l <= s && d[l].priority - d[max].priority < 0) {
				max = l;
			}
			if(l + 1 <= s && d[l + 1].priority - d[max].priority < 0) {
				max = r;
			}
		} else {
			if(l <= s && d[l].priority - d[max].priority > 0) {
				max = l;
			}
			if(l + 1 <= s && d[l + 1].priority - d[max].priority > 0) {
				max = r;
			}
		}
		var a;
		var b;
		var t;
		if(max != p) {
			a = d[max];
			b = d[p];
			d[max] = b;
			d[p] = a;
			t = a.position;
			a.position = b.position;
			b.position = t;
			this.heapify(max,s);
		}
	}
	,grow: function() {
		this.capacity = de_polygonal_ds_tools_GrowthRate.compute(this.growthRate,this.capacity);
		this.resizeContainer(this.capacity);
	}
	,resizeContainer: function(newSize) {
		var t = new Array(newSize + 1);
		de_polygonal_ds_tools_NativeArrayTools.blit(this.mData,0,t,0,this.mSize + 1);
		this.mData = t;
	}
	,__class__: de_polygonal_ds_PriorityQueue
};
var de_polygonal_ds_tools_GrowthRate = function() { };
de_polygonal_ds_tools_GrowthRate.__name__ = true;
de_polygonal_ds_tools_GrowthRate.compute = function(rate,capacity) {
	if(rate > 0) {
		capacity += rate;
	} else {
		switch(rate) {
		case -3:
			capacity <<= 1;
			break;
		case -2:
			capacity = (capacity * 3 >> 1) + 1;
			break;
		case -1:
			var newSize = capacity + 1;
			capacity = (newSize >> 3) + (newSize < 9 ? 3 : 6);
			capacity += newSize;
			break;
		case 0:
			throw new js__$Boot_HaxeError("out of space");
			break;
		}
	}
	return capacity;
};
var de_polygonal_ds_tools_NativeArrayTools = function() { };
de_polygonal_ds_tools_NativeArrayTools.__name__ = true;
de_polygonal_ds_tools_NativeArrayTools.blit = function(src,srcPos,dst,dstPos,n) {
	if(n > 0) {
		if(src == dst) {
			if(srcPos < dstPos) {
				var i = srcPos + n;
				var j = dstPos + n;
				var _g1 = 0;
				var _g = n;
				while(_g1 < _g) {
					var k = _g1++;
					--i;
					--j;
					src[j] = src[i];
				}
			} else if(srcPos > dstPos) {
				var i1 = srcPos;
				var j1 = dstPos;
				var _g11 = 0;
				var _g2 = n;
				while(_g11 < _g2) {
					var k1 = _g11++;
					src[j1] = src[i1];
					++i1;
					++j1;
				}
			}
		} else if(srcPos == 0 && dstPos == 0) {
			var _g12 = 0;
			var _g3 = n;
			while(_g12 < _g3) {
				var i2 = _g12++;
				dst[i2] = src[i2];
			}
		} else if(srcPos == 0) {
			var _g13 = 0;
			var _g4 = n;
			while(_g13 < _g4) {
				var i3 = _g13++;
				dst[dstPos + i3] = src[i3];
			}
		} else if(dstPos == 0) {
			var _g14 = 0;
			var _g5 = n;
			while(_g14 < _g5) {
				var i4 = _g14++;
				dst[i4] = src[srcPos + i4];
			}
		} else {
			var _g15 = 0;
			var _g6 = n;
			while(_g15 < _g6) {
				var i5 = _g15++;
				dst[dstPos + i5] = src[srcPos + i5];
			}
		}
	}
};
de_polygonal_ds_tools_NativeArrayTools.nullify = function(a,first,n) {
	if(n == null) {
		n = 0;
	}
	if(first == null) {
		first = 0;
	}
	var min = first;
	var max = n <= 0 ? a.length : min + n;
	while(min < max) a[min++] = null;
	return a;
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,__class__: haxe_ds_ObjectMap
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
js_html_compat_ArrayBuffer.__name__ = true;
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_Uint8Array = function() { };
js_html_compat_Uint8Array.__name__ = true;
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
onmessage = PathfinderThread.prototype.__internal__onMessage;
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
PathfinderThread.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
